## 面向失败设计 理论篇	

### 一、面向失败设计概述

​	故障注定会发生，随着时间的流逝一切软硬件运行终将失败，而保障业务持续可用，取决于我们愿意投入多少精力和成本，沉淀多少能力，是否预料到不可知的情况。

​	因为失败无处不在，尤其当系统架构复杂性增高，随之而来的失败概率也提高了。

> 一个优秀的架构师，通常是一个悲观主义、现实主义者。

**失败原因可能有**：

- 硬件问题：硬件会老化、会被外力损坏、有残次品率
- 软件bug：没有人可以保证程序没有bug，再者现在升级迭代比较快，bug不可避免
- 配置变更错误：运维变更考虑不全而疏漏
- 系统恶化：长时间工作的程序不再可用。如自增变量越界，缓存、磁盘、数据库空间不足
- 超预期流量：双十一或健康码
- 外部攻击：流量或安全攻击。如：DDOS和CC攻击
- 依赖库问题：二方库、三方库可能存在漏洞
- 依赖服务问题：其他服务可能不可用、超时，这种失败导致自己服务不可能，导致持续辐射，变成大面积服务不可用。

**如何应对上述失败**：

- 

## 面向失败设计 实践案例篇

### 一、架构域

#### 1、单点故障



2、负载不均

3、有状态

4、事后监控

5、不可回滚

6、不可降级

7、缺乏隔离

8、缺乏冗余备份

### 二、设计域

1、滥用日志策略

2、缺乏自我保护

3、缓存设计不当

4、容量评估不准

5、耦合过重

6、滥用同步

7、非幂等

8、敏感信息泄漏

9、对失败考虑不充分

10、数据库索引不合理

11、数据库表结构设计不合理

12、误用数据库limit查询

13、小表随意truncate

14、一次性批量delete数据

15、对异常状态进行兜底设计

16、对重要数据备份

### 三、发布域

1、无灰度流程

2、错误灰度方案

3、未经测试上线

4、预发未充分测试

5、无回滚方案

6、回滚方案未验证

7、未评估影响范围

### 四、变更域

1、变更没有记录

2、变更不可管控

3、变更数据没有格式化

4、变更封不封网

5、变更系统自身能力缺失

6、版本不一致

7、业务高峰期进行数据库变更

8、网络变更质量

### 五、编码域

1、魔法值的使用

2、比较包装类的对象值

3、POJO类属性

4、添加集合元素

5、集合遍历时的修改

6、集合排序异常

7、程序流程控制

8、高并发下的单例对象

9、高并发下的ThreadLocal

10、异常捕获处理

11、高并发下的HashMap

12、日志的使用

13、HTTP连接管理

14、参数检查

15、接口签名

16、不合理的参数配置

17、版本依赖问题

18、字符防乱码

19、不限制集合的大小

### 六、测试域

1、测试链路不完全

2、测试引发的性能问题

3、测试引发的数据污染

4、线上引流测试

5、建立测试基线

6、项目重构测试保障

### 七、监控告警域

1、监控误报成本浪费

2、指标采集不标准

3、基础设施产品未关注业务可用性

4、大面积coredump监控

5、监控失效

6、监控配置不合理

7、关键报警无人处理

8、缺乏分维度大盘

9、变更不关注业务监控

### 八、故障处理域

1、应急原则

2、应急启动

3、应急组织

4、跨域协作

5、应急指挥

6、故障复盘

7、快速恢复

## 读后感

- 始于2022年5月1日，计划于应终于2022年5月3日晚之前读完，即花2天的时间来学习。

- 阅读本书的目的：了解应用架构的失败设计理念和实践原则，从而提升自己在系统设计上的眼界。