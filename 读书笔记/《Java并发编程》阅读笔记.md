# 1.  第一章

## 1.1. 第一节

### 1.1.1. 第一点

# 2.  线程安全性

## 2.1. 什么是线程安全

l 线程安全：当多个线程访问某个类时，这个类始终都能表现出与单线程一致的正确行为。

l 一个对象是否是线程安全，取决于它是否被多个线程访问。伴随着“读取-修改-写入”或“先检查后执行”的操作，都可能是不安全的。

l 当一个类不安全时（原子性和可见性不能满足时），可通过以下三种方式修复：

A．不再线程之间共享状态变量（线程封闭）

B．将状态变量修改为final变量（不变性）

C．在访问状态变量时使用同步。（本章讨论点）

l Java同步关键字是synchronized，其他加锁方式还有volatile、显示锁、原子变量。

l 一定安全的线程的类：无状态类、

l 无状态类：不包含任何内部成员变量（域），也不包含对其他类成员变量的引用（域引用）；如Servlet类。

## 2.2. 原子性

l 原子性：一组语句作为一个不可分割的单元被执行。

l 这里举例Servlet中增加状态变量count，并作count ++ ，会导致竞态条件的并发问题。简单的延时加载getInstance也竞态条件的一种。

l 竞态条件：由于线程执行时序而出现不正确的结果。

l 本例子中Servlet的竞态条件问题，可以通过原子性变量AtomicLong解决。

## 2.3. 加锁机制

l 当原子性变量解决不了线程安全问题，如涉及多个原子性变量，并且彼此相关产生约束，需要组合一起作为一个单元执行。这时候可采用syncronized加锁方式。

l Syncronized称为内置锁，是种互斥锁，可重入。内置锁包含两部分：锁对象的引用和锁保护的代码块。由于只能有一个线程能持有，其他线程必须阻塞等待。所以代码块中如单线程一般不被干扰。

l 可重入性：线程可以获得自己持有的已经持有的锁。是为了避免死锁情况发生。想想同步方法递归调用。

l 重入实现方法：每个锁关联一个计数值和所有者线程。计数值为0认为锁不被任何线程持有。当锁被线程持有时，计数器置位1，所有者置为该线程。当同一线程再获取该锁，计数值递增。线程退出同步代码块，计数器递减，直至为0释放锁。

## 2.4. 用锁规范

l 规范：如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步，包括读和写。且都要使用同一个锁。

l 常用加锁约定是，将所有可变状态封装在对象内部，通过对象内置锁对所有路径进行同步。如getName和setName方法都要加上synchronized，使用对象内置锁加锁

l 每个对象都有一个内置锁，只是为了免去显式的创建锁对象。

## 2.5. 用锁的活跃性与性能

l 这里举例说明了为方法或大段代码加synchronized可能引起持有锁过长等性能问题。尤其是无法快速完成的IO操作。

l 最好的做法是对代码做分隔，只对需要同步的代码或变量使用同步块。注意不要违背2.4的用锁规范。

l 单个变量上实现原子操作，原子变量有用，但使用了同步代码块构建原子操作，使用两种同步机制会带来混乱，在安全和性能也没有好处，所以可以只使用内置锁同步。

# 3.  对象的共享

## 3.1. 可见性

l 可见性：由于缓存寄存器和重排序的影响，无法确保执行读操作的线程及时的看到其他线程的写入值。

l 重排序：在没有同步情况下，编辑器、处理器、JVM都可能对操作的执行顺序进行意想不到的调整，以满足性能或简化。例如：两个不相干变量AB的声明，可能在执行时变成BA顺序声明。

l 可见性问题会导致读取失效数据或错误数据。

l 读取错误数据的示例是，非volatile的long和double型的64位变量，在读取时可分为两个32位操作，可能读取一个新前32位和旧后32位的组合体。

l 解决可见性的方式：加锁、volatile变量。加锁可以保证进入同步块的线程，能够读取到上一个线程在同步块修改变量的最新值。Volatile声明的变量不会缓存在寄存器，也不会被重排序。

l 加锁可以保证原子性和可见性，volatile只能保证可见性。

## 3.2. 发布和逸出

l 发布：一个对象能在作用域（本类）之外的代码中使用。例如：对象引用保存到其他代码可以访问的地方；非私有方法返回该引用；对象引用传递到其他类的方法中。

l 逸出：不应该发布的对象被发布了。发布某个对象时，间接的发布了其他对象。例如发布集合，集合中的其他对象引用也被发布了。

l 间接发布对象：一个已经被发布的对象能够通过非私有变量和方法到达其他的对象，这些其他对象也被发布了。

l 发布要确保线程安全。对于内部状态，发布可能破坏封装性。

l 封装最主要的原因：可以保证其他类和线程不会勿用发布对象。使对程序的正确性分析变得可能，无意间破坏设计约束条件变得更难。

l 在构造方法中，不要是this逸出。例如在构造方法中启动一个线程。如果想在构造函数中注册事件或启动线程，可以使用私有构造函数和一个工厂方法。

## 3.3. 线程封闭

l 线程封闭：当访问共享可变数据时，需要使用同步，避免使用同步的方式就是不共享数据，可变数据如在单线程被使用一样。线程封闭的对象只能由一个线程拥有，也只能由该线程修改。

l 线程封闭是使对象不被发布。

l 举例如数据库连接池是线程安全的，但其包含的Connection对象，不为线程安全。因为线程从连接获取一个Connection对象，在返回之前，连接池不会把它分配给其他线程，隐含地将Conn封闭在线程中。

线程封闭的3种方式：

l Ad-hoc：维护线程封闭性完全由程序实现。（连接池应该就是这种）

l 栈封闭：通过局部变量才能访问对象，保证局部变量不逸出。

l Threadlocal类：为每一个访问共享可变数据的线程存一份独立的副本。其get总是返回当前线程调用set时设置的值。简单理解为ThreadLocal<T>包含了Map<Thread,T>对象，但实际上特定于线程的副本保存在Thread对象中。Threadlocal类似于全局变量，可降低重用性，小心使用

## 3.4. 不变性



l 不可变对象一定是线程安全的，不需要考虑同步问题。

不可变对象满足三个条件：

l 对象创建后其状态不能修改。（只有构造函数能初始化内部变量，没有set、add）

l 对象的所有域都是final类型

l 对象是正确创建的，this引用没有逸出。

 

l 举例来说，某类两个私有final变量，只在初始化时赋值，类中只有get方法。此类为不可变类，创建的不可变对象如果需要更改私有final变量值，就重新再构造一个出来。

l 除非更高的可见性，否则所有域都声明为私有。除非某个域可变，否则应声明为final

## 3.5. 安全发布

l 这里的安全发布强调new一个对象，必须在构造完成后的被使用。

l 不正确的发布：没有使用同步等策略，会导致没有构造完的对象被其他线程调用，最终导致的结果是对象内的域是失效值或者对象引用是失效的。

l Jvm对不可变对象提供了特殊的初始化安全性保证，即不需要额外同步，任何线程发布不可变对象一定是安全的。

发布可变对象，对象的引用和对象的状态必须对其他线程可见。按以下4种方式可安全发布对象：

l 在静态初始化函数中初始化一个对象引用，JVM内部有同步机制，可以保证安全发布:public static Holder h = new Holder(42);或静态代码块

l 将对象的引用保存到valatile类型的域或者AtomicReferance对象中

l 将对象的引用保存到某个正确构造对象的final类型域中

l 将对象的引用保存到一个由锁保护的域中：将引用保存到Vector或ConcurrentMap等线程安全容器中。

l 事实不可变对象：对象从技术上可变，但实际使用上其状态在发布后不会再改变。例如：Date。Date本身可变，但一般都作为不可变对象使用。

l 不可变对象可以通过任意机制发布；事实不可变必须通过安全方式发布；可变对象必须通过安全方式发布，并且必须是线程安全或者由某个锁保护起来。

l 综上，获取一个对象引用时，需要考虑使用它之前是否需要获得一个锁？是否可以修改它的状态？是只读？发布一个对象时必须说明访问方式。

# 4.  对象的组合

## 4.1. 第一节

### 4.1.1. 第一点

# 5.  第一章

## 5.1. 第一节

### 5.1.1. 第一点

# 6.  第一章

## 6.1. 第一节

### 6.1.1. 第一点

# 7.  取消与关闭

## 7.1. 第一节

### 7.1.1. 第一点

## 7.2. 停止基于线程的服务

l 定义：应用程序停止的时候，程序拥有的线程服务（如线程池）也要停止，该线程服务称为基于线程的服务。

l 停止线程服务，其拥有的线程也要停止。线程停止原则是：**线程的所有者（创建线程的类），才可以操作线程**[[S1\]](#_msocom_1) ，当然也包括停止线程。同时线程的所有权不可转移，程序拥有服务，服务拥有线程，不代表程序可以操作（关闭）线程。也就是说线程只能被线程服务停止。

l ExecutorService线程服务提供了shutdown和shutdownNow方法。其他服务也应该提供关闭机制。

### 7.2.1. 示例：日志服务

l 内联日志：直接输出日志，会给高容量的程序带来一定性能开销。

l 队列实现：生产线程将日志放入队列中，消费线程处理这些日志。也就是生产-消费模型。

l 日志服务的队列实现，在关闭服务时存在的问题是，直接关闭服务，在队列中等待被处理的消息将会丢失。如果关闭之前队列是满的，生产线程会被阻塞，关闭之后，阻塞没有被解除。

l 标志符解决法：设置“已请求关闭”标志，在数据存入队列之前进行判断，为true的话，抛出异常。而消费者则在该标志为true后，处理完队列之后关闭。由于标志是先判断后put队列，所以该方法不可靠。

l 最佳解决：按照标识符解决法，在生产者判断关闭情况处，增加原子计数器++。在消费者判断标志处，增加原子判断，同时在处理队列成功后，原子计数器--。

### 7.2.2. 关闭ExecutorService

l ExecutorService提供了关闭方法，将管理线程的工作委托给一个ExecutorService省事。服务内部持有一个ExecutorService，所有线程由ExecutorService创建和销毁。

### 7.2.3. “毒丸”对象

l 还是日志系统为例，当服务停止时，生产者收到中断请求，在finally中向队列放入一个毒丸对象。当消费者收到毒丸对象后，关闭自己。

l 消费者和生产者数量已知时，才可以使用该方法，否则该方法不可靠。

### 7.2.4. 只执行一次服务

l 当一次只执行一批任务时，服务方法内部可新建ExecutorService对象，在循环里将任务放入ExecutorService对象中执行，finally中直接让ExecutorService对象shutdown，并awaitTermination阻塞直到任务全部执行完毕，返回需要的数据。（还是看源码吧）

### 7.2.5. shutdownNow的局限性

l 局限性：只能返回提交未处理的任务，不能返回正在处理未结束的任务。

l 解决方法：采用代理模式，服务继承AbstractExecutorService，重写execute方法，内部再持有一个ExecutorService对象，execute中调用ExecutorService对象的execute方法，由ExecutorService对象执行任务。而这个任务是封装了一层，增加任务中断后，将当前任务存起来的finally。

l 存在竞态条件，需要确保任务是幂等的。

## 7.3. 处理非正常的线程终止

l 线程提前死亡最多原因是RuntimeException。如果你不希望线程由于异常悄悄的失败，请将任务封装在try-catch-finally中，保证异常被捕获和处理。

l 如果没有主动捕获任务异常，thread api提供uncaughtExceptionHandler，可以为线程或线程池设置自定义的handler，默认的handler是把线程和异常打印在控制台。

l Execute提交的任务抛出的异常可以交给handler，而submit提交的任务，异常会被Future.get封装在ExecutionException中重新抛出。

## 7.4. JVM关闭

### 7.4.1. 关闭钩子

l JVM在关闭之前处理的任务。通过Runtime.addShutdownHook增加任务。

l 增加的钩子任务是并行执行，所以没有调用顺序。且钩子任务应该是线程安全的。

l 关闭钩子应该用于清理工作。如果两个关闭钩子操作同一个服务，会引发问题。应该同一服务对应一个关闭钩子。最好的方式是所有服务在关闭钩子中串行执行。

### 7.4.2. 守护线程

l 线程分为：普通线程与守护线程。区别只在于JVM关闭时的操作。如果JVM停止时，所有普通线程都已结束，则守护线程将被抛弃—不执行finally，也不执行回卷栈。

l 守护线程只做一些辅助性的工作，并且不会阻止JVM关闭。比如垃圾回收器。

l 守护线程只需要在普通线程start之前，设置setDaemon(true)即可。守护线程中创建的线程仍然是守护线程。

l 守护线程应该少使用，必须使用时也永远不去操作固有资源，如文件、数据库，因为它会在任何时候发生中断。

### 7.4.3. 终结器

l 定义：就是finalize方法。显示的将对象释放。

l 结论：由于线程同步复杂性和回收性能问题，避免重写和使用终结器

# 8.  线程池的使用

------

