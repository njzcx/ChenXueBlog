> 原文：https://blog.51cto.com/u_16099352/7516399

# 结论

1. 同一个ClassLoader实例加载的类不能重复，后面加载的类文件不会生效
2. 在web-inf/classes中的类优先于jar包中的加载，此时web-inf/classes中的类生效
3. 不同的jar包都有相同类，则为先加载的jar中的类生效。不同jar加载顺序依赖java -classpath参数指定的顺序。若未指定顺序，则依赖文件系统，可能随机，可能是英文字典顺序。

# 原理

## 1. 同一个类只会被加载器加载一次

JVM 类加载具有缓存机制，每个类加载的时候首先检查一遍，类是否被当前类加载器加载。若未被加载，先交给其父类加载器加载，父类加载器不能加载，才会交给当前类加载器。

当前类加载器加载完成之后，将会将其缓存起来。

![img](https://cdn.nlark.com/yuque/0/2025/png/259613/1743415250417-e0c6328b-6da1-4adb-9fbc-ccd798b3e903.png)

类加载的核心源码位于 ClassLoader#loadClass：

![img](https://cdn.nlark.com/yuque/0/2025/png/259613/1743415264578-6959f8cb-3454-4472-880b-a6dfc3399070.png)

① 处将会检查ClassLoader#findLoadedClass 最终将会调用 ClassLoader#findLoadedClass0,这是一个 native 方法，最终将会根据类名加类加载器为键值查找缓存。

每个类加载器负责的加载范围都不一样：

- BootstrapClassLoader 引导类加载加载最核心的类库，如 $JAVA_HOME/jre/lib/
- ExtClassLoader 扩展类加载器负责加载$JAVA_HOME/jre/lib/ext下的一些扩展类
- AppClassLoader 应用类加载器将加载 classpath 指定的类。

我们运行的应用依赖的各种类，一般将会由 AppClassLoader 记载，同名类被加载后，下次碰到就不会再被加载。

画外音:利用缓存加快查询速度

## 2. 不同环境，类的加载顺序不同

Java 可以使用 -classpath 参数指定依赖类所在位置。

类的加载顺序可以通过以下方式指定：

```bash
java -classpath a.jar:b.jar:c.jar xx.xx.Main
```

上面这种方式，类加载首先会从 a.jar 中查找相关类，找不到才会继续往后查找。所以可以通过这种方式可以指定使用哪个 jar 包内同名类。

但是这种方式有点繁琐，如果依赖 100 个 jar 包，需要全部写上去。

所以生产环境可以使用使用 shell 命令将 jar 拼接起来：

```bash
LIB_DIR=lib
LIB_JARS=`ls $LIB_DIR|grep .jar|awk '{print "'$LIB_DIR'/"$0}'|tr "\n" ":"`
```

另外 java 支持通配符的写法:

```bash
java -classpath './*' xx.xx.Main
```

这种方式的加载顺序将会受到底层系统文件加载顺序影响。

## 3. 复现依赖冲突

假设我们现在应用依赖如下:

![img](/Users/zhangchenxue/CodeProject/njzcx/ChenXueBlog/开发语言/Java/images/同名类加载优先级/1743415425083-41d97cea-f1fe-49b0-a1ff-b1f6fe8d0a53.png)

A 应用依赖 B、C，且 B，C 中存在同包同名类 org.example.App，代码如下：

![img](https://cdn.nlark.com/yuque/0/2025/png/259613/1743415438004-c1681ef1-da49-450c-927c-93f6092b7578.png?x-oss-process=image%2Fcrop%2Cx_68%2Cy_72%2Cw_1052%2Ch_904)

如果指定 jar 包顺序启动应用：

```bash
# A,B,C 放置同一文件夹下
java -classpath A-1.0-SNAPSHOT.jar:B-1.0-SNAPSHOT.jar:C-1.0-SNAPSHOT.jar org.example.ClassA
```

日志输出如下：

![img](https://cdn.nlark.com/yuque/0/2025/png/259613/1743415472133-5f80e297-7728-4542-9ede-e8fc3dfe24a9.png)

改变 B ,C 顺序：

![img](/Users/zhangchenxue/CodeProject/njzcx/ChenXueBlog/开发语言/Java/images/同名类加载优先级/1743415480579-d30e947b-576c-4503-9435-dde800c46143.png)

类加载器的类的查找顺序将会通过 classpath 指定顺序从前往后查找。

如果使用通配符启动：

```bash
java -classpath './*' org.example.ClassA
```

这种情况 jvm 到底加载那个类就成了薛定谔的类了，运行之前无法确定加载类来自哪个 jar 包。

# 查看加载来源

## 1. 使用 verbose:class 打印加载类

我们可以在 jvm 启动脚本加入如下参数 -verbose:class,然后重启，日志里会打印出每个类的加载信息。

```bash
java -verbose:class -classpath './*' xx.xx.Main
```

日志输出如下:

![img](https://cdn.nlark.com/yuque/0/2025/png/259613/1743415611507-97a4b053-b309-4406-a237-7531fefd7650.png)

通过这种方式可以看到加载类来源于哪个Jar包。

不过这种方式需要重启应用，对生产系统来说，影响还是比较大,不太优雅。

## 2. Arthas 查到来源类

阿里开源项目 Arthas sc 命令可以用来查找加载类的信息。。

sc 命令是 Search-Class 简写，这个命令能搜索出已经加载到 JVM 中的 Class 信息，支持参数如下表格所示。

![img](https://cdn.nlark.com/yuque/0/2025/png/259613/1743415624073-54662d71-c08e-45c0-84ad-c04ed9cdb1e7.png)

程序启动之后，启动 arthas，进入 A 应用。（tangtao_xp注释，这个地方是启动arthas后attach到已启动的jvm程序）

运行如下命令：

```bash
sc -d org.example.App
```

输出结果如下 :

![img](https://cdn.nlark.com/yuque/0/2025/png/259613/1743415637825-d77494f0-2745-4c12-9efe-e7210550b182.png)

code-source 显示当前查找类 org.example.App 来自的 C。

另外我们可以 jad 命令反编译类，在线查看源码。

![img](https://cdn.nlark.com/yuque/0/2025/png/259613/1743415649344-9478f109-9f1e-4a46-a4fb-318aa196ff17.png)